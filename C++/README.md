A quick summary of the whole process from C++ code (several files) and to a final executable:

* The **preprocessor** is run, which parses all the directives which starts with a '#'. The #include directive concatenates the included file with inferior, for example. It also does macro-replacement and token-pasting.  

* The **actual compiler** runs on the intermediate text file after the preprocessor stage, and emits assembler code.  

* The **assembler** runs on the assembly file and emits machine code, this is usually called an object file and follows the binary executable format of the operative system in question. For example, Windows uses the PE (portable executable format), while Linux uses the Unix System V ELF format, with GNU extensions. At this stage, symbols are still marked as undefined.  

* Finally, **the linker** is run. All the previous stages were run on each translation unit in order. However, the linker stage works on all the generated object files which were generated by the assembler. The linker resolves symbols and does a lot of magic like creating sections and segments, which is dependent on the target platform and binary format. Programmers aren't required to know this in general, but it surely helps in some cases.



## iostream  

### istream  

### ostream
* '\n' : new line으로 '\n'다음 문자들은 buffer에 저장만 되어있고 출력이 안될 수도 있다.
* endl : 줄바꿈을 하고 buffer에 있는 것을 모두 출력한다.(비운다)
* flush : 줄바꿈을 안하고 buffer에 있는 것을 모두 출력한다.(비운다)
